# Building a Second Brain in Emacs and Org-Mode - Forte Labs

## Metadata

* Author: 
* Full Title: Building a Second Brain in Emacs and Org-Mode - Forte Labs
* Category: #Type/Highlight/Article
* URL: https://fortelabs.co/blog/building-a-second-brain-in-emacs-and-org-mode/

## Highlights

* Much of what I’ve learned from using Emacs is related to programming. Simply by using Emacs over time, you will be exposed to its internal programming language, Emacs Lisp. If you choose to, you can take that as an opportunity to learn to program for fun and for profit. Here are some of the concepts and tools that I’ve learned through using Emacs:
  Literate programming: Blocks of code alternate with blocks of explanatory text, similar to Jupyter notebooks, Mathematica, and others
  Pandoc: Pandoc converts documents between different formats, including Emacs Org-Mode files
  Post-fix calculators: Emacs has a powerful built-in calculator, Emacs Calc. It is a “post-fix calculator,” which means you express equations like “2 + 2 =” as “2 2 +” and get 4. Accountants use post-fix calculators for efficient calculations
  Regular expressions: a mini-programming language for querying and manipulating text. Most programming languages and software development tools support them. You can actually use them in Google Docs!
  Version control: Version control keeps track of the history of changes to files over time. The most popular form of version control at the moment is Git. Emacs has an excellent Git interface, Magit. Magit users often report that it makes Git easier to use, and that they also learn its more advanced features by exploring the interface
* Those are just some of the tools I’ve learned through Emacs. What principles have I learned?
  Keyboard first: As with many other programs, Emacs rewards you for doing everything at the keyboard, with keyboard shortcuts. This is definitely a very efficient way of doing things with computers
  Outlining: Org-Mode takes the view that everything is (or is related to) an outline item. Org-Mode is the best outliner I’ve come across. If you’ve used Workflowy, and loved it, well, that’s just a fraction of the goodness that’s available in Org-Mode
  Self-documenting code: Emacs makes it very easy to get documentation. You kind of have to use this to believe it, but it’s easily the best documentation of any software project I’ve ever used, simply because it’s so discoverable and dynamic
  Environment and configurability: If you don’t like it, you can change it. If you want some functionality that’s not already there, you can roll your own. This is partly because Emacs is free software, and partly because of its use of Lisp. As a downside, this spoils you for software where this isn’t taken for granted
  Software is memetic: Emacs configurations typically have snippets copied and adapted from others. Will Mengarini and others have compared this to evolution and horizontal transfer
  Our tools shape us: In his post “You are your tools,” Daniel Lemire discusses how learning new tools manifests a particular aspect of the growth mindset, and that learning and using new tools makes us smarter. Emacs is a wonderful place to explore this. It can support most programming languages; packages are made for using many tools, paradigms, and workflows; and more are available all the time
  Use the best tool for the job: In Sacha Chua’s interview with Carsten Dominik, Org-mode’s creator, he talks about using a derivative version of Emacs, microEmacs, and how that experience “…taught me… something really basic…. I made the decision that I would never start using an inferior tool. It doesn’t really make sense. For example, I didn’t use Awk, I used Perl, because I knew that if you try to program something with Awk, you will just hit your head against the wall at some point. Perl is just so open-ended that whatever you want to do, you will be able to do in this language… I think it’s the same is true for Emacs. Basically, \[it’s\] just completely unlimited. Whatever you want to do is there.”
  Emacs isn’t the best tool for every job, but you should identify what the best tool is for each job, and use that.
* Software is contingent
  There’s one final thing I’ve learned from using Emacs and Org-mode. I used to primarily use other people’s software. I’d use the available operating system — Windows or MacOS. I’d use the available programs — Microsoft Office, Internet Explorer, Safari, etc. Those were the options. These situations limited my perspective. I could try a new program if it came along, such as Firefox, or LibreOffice, but I only had so many options. If I didn’t like something, or I found a bug, that was it. Software is just the way it is, and you can’t change it.
  But when I started using software that I had to configure, software that I could extend, I saw that there was a far broader range of possibilities. Real people make software, and those people have preferences and priorities, whims, opinions, and needs. If you learn how to make software, or use software that is easy to explore or change, you can align the software with your preferences and priorities. Or not. You are free to choose. Not only do our tools shape us; we shape our tools.
